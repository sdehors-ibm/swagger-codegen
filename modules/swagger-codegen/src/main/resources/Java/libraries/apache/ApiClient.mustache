package {{invokerPackage}};

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.apache.commons.io.IOUtils;
import org.apache.http.*;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.client.methods.HttpUriRequest;
import org.apache.http.client.utils.URIBuilder;
import org.apache.http.entity.ByteArrayEntity;
import org.apache.http.impl.client.CloseableHttpClient;

import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.net.URISyntaxException;
import java.net.URLEncoder;
import java.text.DateFormat;
import java.util.*;
import java.util.Map.Entry;

import {{invokerPackage}}.auth.Authentication;
import {{invokerPackage}}.auth.HttpBasicAuth;
import {{invokerPackage}}.auth.ApiKeyAuth;
import {{invokerPackage}}.auth.OAuth;

{{>generatedAnnotation}}
public class ApiClient {

protected Map<String, String> defaultHeaderMap = new HashMap<String, String>();
protected String basePath = "{{{basePath}}}";
protected boolean debugging = false;
protected int connectionTimeout = 0;
private int readTimeout = 0;

protected CloseableHttpClient httpClient;
protected JSON json;
protected String tempFolderPath = null;

protected Map<String, Authentication> authentications;

protected DateFormat dateFormat;

public ApiClient(CloseableHttpClient httpClient) {
    json = new JSON();
    this.httpClient = httpClient;

    // default date format
    this.dateFormat = new RFC3339DateFormat();

    // Setup authentications (key: authentication name, value: authentication).
    authentications = new HashMap<String, Authentication>();{{#authMethods}}{{#isBasic}}
    authentications.put("{{name}}", new HttpBasicAuth());{{/isBasic}}{{#isApiKey}}
    authentications.put("{{name}}", new ApiKeyAuth({{#isKeyInHeader}}"header"{{/isKeyInHeader}}{{^isKeyInHeader}}"query"{{/isKeyInHeader}}, "{{keyParamName}}"));{{/isApiKey}}{{#isOAuth}}
    authentications.put("{{name}}", new OAuth());{{/isOAuth}}{{/authMethods}}
    // Prevent the authentications from being modified.
    authentications = Collections.unmodifiableMap(authentications);
}

/**
 * Gets the JSON instance to do JSON serialization and deserialization.
 *
 * @return JSON
 */
public JSON getJSON() {
  return json;
}

public String getBasePath() {
  return basePath;
}

public ApiClient setBasePath(String basePath) {
  this.basePath = basePath;
  return this;
}

/**
 * Get authentications (key: authentication name, value: authentication).
 *
 * @return Map of authentication object
 */
public Map<String, Authentication> getAuthentications() {
  return authentications;
}

/**
 * Get authentication for the given name.
 *
 * @param authName The authentication name
 * @return The authentication, null if not found
 */
public Authentication getAuthentication(String authName) {
  return authentications.get(authName);
}

/**
 * Helper method to set access token for the first OAuth2 authentication.
 *
 * @param accessToken Access token
 */
public void setAccessToken(String accessToken) {
  for (Authentication auth : authentications.values()) {
    if (auth instanceof OAuth) {
      ((OAuth) auth).setAccessToken(accessToken);
      return;
    }
  }
  throw new RuntimeException("No OAuth2 authentication configured!");
}

/**
 * Set the User-Agent header's value (by adding to the default header map).
 *
 * @param userAgent Http user agent
 * @return API client
 */
public ApiClient setUserAgent(String userAgent) {
  addDefaultHeader("User-Agent", userAgent);
  return this;
}

/**
 * Add a default header.
 *
 * @param key The header's key
 * @param value The header's value
 * @return API client
 */
public ApiClient addDefaultHeader(String key, String value) {
  defaultHeaderMap.put(key, value);
  return this;
}


/**
 * The path of temporary folder used to store downloaded files from endpoints
 * with file response. The default value is <code>null</code>, i.e. using
 * the system's default tempopary folder.
 *
 * @return Temp folder path
 */
public String getTempFolderPath() {
  return tempFolderPath;
}

/**
 * Set temp folder path
 *
 * @param tempFolderPath Temp folder path
 * @return API client
 */
public ApiClient setTempFolderPath(String tempFolderPath) {
  this.tempFolderPath = tempFolderPath;
  return this;
}

/**
 * Get the date format used to parse/format date parameters.
 *
 * @return Date format
 */
public DateFormat getDateFormat() {
  return dateFormat;
}

/**
 * Set the date format used to parse/format date parameters.
 *
 * @param dateFormat Date format
 * @return API client
 */
public ApiClient setDateFormat(DateFormat dateFormat) {
  this.dateFormat = dateFormat;
  // also set the date format for model (de)serialization with Date properties
  this.json.setDateFormat((DateFormat) dateFormat.clone());
  return this;
}

/**
 * Parse the given string into Date object.
 *
 * @param str String
 * @return Date
 */
public Date parseDate(String str) {
  try {
    return dateFormat.parse(str);
  } catch (java.text.ParseException e) {
    throw new RuntimeException(e);
  }
}

/**
* Format the given Date object into string.
     *
* @param date Date
* @return Date in string format
*/
public String formatDate(Date date) {
return dateFormat.format(date);
}

/**
* Format the given parameter object into string.
     *
* @param param Object
* @return Object in string format
*/
public String parameterToString(Object param) {
if (param == null) {
return "";
} else if (param instanceof Date) {
return formatDate((Date) param);
} else if (param instanceof Collection) {
StringBuilder b = new StringBuilder();
for(Object o : (Collection)param) {
if(b.length() > 0) {
b.append(',');
}
b.append(String.valueOf(o));
}
return b.toString();
} else {
return String.valueOf(param);
}
}

/*
* Format to {@code Pair} objects.
* @param collectionFormat Collection format
* @param name Name
* @param value Value
* @return List of pairs
*/
public List<Pair> parameterToPairs(String collectionFormat, String name, Object value){
    List<Pair> params = new ArrayList<Pair>();

        // preconditions
        if (name == null || name.isEmpty() || value == null) return params;

        Collection valueCollection;
        if (value instanceof Collection) {
        valueCollection = (Collection) value;
        } else {
        params.add(new Pair(name, parameterToString(value)));
        return params;
        }

        if (valueCollection.isEmpty()){
        return params;
        }

        // get the collection format (default: csv)
        String format = (collectionFormat == null || collectionFormat.isEmpty() ? "csv" : collectionFormat);

        // create the params based on the collection format
        if ("multi".equals(format)) {
        for (Object item : valueCollection) {
        params.add(new Pair(name, parameterToString(item)));
        }

        return params;
        }

        String delimiter = ",";

        if ("csv".equals(format)) {
        delimiter = ",";
        } else if ("ssv".equals(format)) {
        delimiter = " ";
        } else if ("tsv".equals(format)) {
        delimiter = "\t";
        } else if ("pipes".equals(format)) {
        delimiter = "|";
        }

        StringBuilder sb = new StringBuilder() ;
        for (Object item : valueCollection) {
        sb.append(delimiter);
        sb.append(parameterToString(item));
        }

        params.add(new Pair(name, sb.substring(1)));

        return params;
        }

        /**
        * Check if the given MIME is a JSON MIME.
        * JSON MIME examples:
        *   application/json
        *   application/json; charset=UTF8
        *   APPLICATION/JSON
        *   application/vnd.company+json
        * "* / *" is also default to JSON
     *
        * @param mime MIME
        * @return True if the MIME type is JSON
        */
        public boolean isJsonMime(String mime) {
        String jsonMime = "(?i)^(application/json|[^;/ \t]+/[^;/ \t]+[+]json)[ \t]*(;.*)?$";
        return mime != null && (mime.matches(jsonMime) || mime.equals("*/*"));
        }

        /**
        * Select the Accept header's value from the given accepts array:
        *   if JSON exists in the given array, use it;
        *   otherwise use all of them (joining into a string)
        *
        * @param accepts The accepts array to select from
        * @return The Accept header to use. If the given array is empty,
        *   null will be returned (not to set the Accept header explicitly).
        */
        public String selectHeaderAccept(String[] accepts) {
        if (accepts.length == 0) {
        return null;
        }
        for (String accept : accepts) {
        if (isJsonMime(accept)) {
        return accept;
        }
        }
        return StringUtil.join(accepts, ",");
        }

        /**
        * Select the Content-Type header's value from the given array:
        *   if JSON exists in the given array, use it;
        *   otherwise use the first one of the array.
        *
        * @param contentTypes The Content-Type array to select from
        * @return The Content-Type header to use. If the given array is empty,
        *   JSON will be used.
        */
        public String selectHeaderContentType(String[] contentTypes) {
        if (contentTypes.length == 0) {
        return "application/json";
        }
        for (String contentType : contentTypes) {
        if (isJsonMime(contentType)) {
        return contentType;
        }
        }
        return contentTypes[0];
        }

        /**
        * Escape the given string to be used as URL query value.
     *
        * @param str String
        * @return Escaped string
        */
        public String escapeString(String str) {
        try {
        return URLEncoder.encode(str, "utf8").replaceAll("\\+", "%20");
        } catch (UnsupportedEncodingException e) {
        return str;
        }
        }

        /**
        * Serialize the given Java object into string entity according the given
        * Content-Type (only JSON is supported for now).
     *
        * @param obj Object
        * @param formParams Form parameters
        * @param contentType Context type
        * @return Entity
        * @throws ApiException API exception
        */
    public HttpEntity serialize(Object obj) throws ApiException, JsonProcessingException {
        // We let jackson handle the serialization
        return new ByteArrayEntity(json.getMapper().writeValueAsBytes(obj));
        }

        /**
        * Deserialize response body to Java object according to the Content-Type.
     *
        * @param <T> Type
            * @param response Response
            * @param returnType Return type
            * @return Deserialize object
            * @throws ApiException API exception
            */
    public <T> T deserialize(HttpResponse response, TypeReference<T> returnType) throws ApiException, IOException {
                if (response == null || returnType == null) {
                return null;
                }

        return json.getMapper().readValue(response.getEntity().getContent(), returnType);
                    }


                    /**
                    * Invoke API by sending HTTP request with the given options.
                    *
                    * @param <T> Type
                        * @param path The sub-path of the HTTP URL
                        * @param method The request method, one of "GET", "POST", "PUT", "HEAD" and "DELETE"
                        * @param queryParams The query parameters
                        * @param body The request body object
                        * @param headerParams The header parameters
                        * @param formParams The form parameters
                        * @param accept The request's Accept header
                        * @param contentType The request's Content-Type header
                        * @param authNames The authentications to apply
                        * @param returnType The return type into which to deserialize the response
                        * @return The response body in type of string
                        * @throws ApiException API exception
                        */
    public <T> ApiResponse<T> invokeAPI(String path, String method, List<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String accept, String contentType, String[] authNames, TypeReference<T> returnType) throws ApiException {

        HttpUriRequest request;
        try {
                            updateParamsForAuth(authNames, queryParams, headerParams);

            URIBuilder builder = new URIBuilder(this.basePath + path);

                            if (queryParams != null) {
                            for (Pair queryParam : queryParams) {
                            if (queryParam.getValue() != null) {
                        builder.setParameter(queryParam.getName(), queryParam.getValue());
                            }
                            }
                            }


            switch (method) {
                case "POST":
                    request = new HttpPost(builder.build());
                    ((HttpPost) request).setEntity(serialize(body));
                    break;
                case "GET":
                    request = new HttpGet(builder.build());
                    break;
                default:
                    throw new UnsupportedOperationException("method not supported");
            }

                            for (Entry<String, String> entry : headerParams.entrySet()) {
                            String value = entry.getValue();
                            if (value != null) {
                    request.setHeader(entry.getKey(), value);
                            }
                            }

                            for (Entry<String, String> entry : defaultHeaderMap.entrySet()) {
                            String key = entry.getKey();
                            if (!headerParams.containsKey(key)) {
                            String value = entry.getValue();
                            if (value != null) {
                        request.setHeader(key, value);
                            }
                            }
                            }
        } catch (IOException | URISyntaxException e) {
            throw new ApiException(e);
        }

        HttpResponse response = null;
                            try {

            response = httpClient.execute(request);

            int statusCode = response.getStatusLine().getStatusCode();
                        Map<String, List<String>> responseHeaders = buildResponseHeaders(response);

                        if (statusCode == HttpStatus.SC_NO_CONTENT) {
                            return new ApiResponse<>(statusCode, responseHeaders);
                            } else if (statusCode >= HttpStatus.SC_OK && statusCode < HttpStatus.SC_MULTIPLE_CHOICES) {
                                if (returnType == null)
                                return new ApiResponse<>(statusCode, responseHeaders);
                                else
                                return new ApiResponse<>(statusCode, responseHeaders, deserialize(response, returnType));
                                } else {
                                String message = "error";
                                String respBody = null;
                if (response.getEntity() != null) {
                    respBody = IOUtils.toString(response.getEntity().getContent());
                                message = respBody;
                                }
                                throw new ApiException(
                        response.getStatusLine().getStatusCode(),
                                message,
                                buildResponseHeaders(response),
                                respBody);
                                }
        } catch (IOException e) {
            throw new ApiException(e);
                                } finally {
                                try {
                // make sure it's closed ??
                if (response != null) {response.getEntity().getContent().close();};
                                } catch (Exception e) {
                                // it's not critical, since the response object is local in method invokeAPI; that's fine, just continue
                                }
                                }
                                }

    protected Map<String, List<String>> buildResponseHeaders(HttpResponse response) {
                                    Map<String, List<String>> responseHeaders = new HashMap<String, List<String>>();
        Header[] headersArray = response.getAllHeaders();
        for (int i = 0; i < headersArray.length; i++) {
            HeaderElement[] elements = headersArray[i].getElements();
                                                List<String> headers = new ArrayList<String>();
            for (HeaderElement o : elements) {
                headers.add(o.getValue());
                                                    }
            responseHeaders.put(headersArray[i].getName(), headers);
                                                    }
                                                    return responseHeaders;
                                                    }

                                                    /**
                                                    * Update query and header parameters based on authentication settings.
                                                    *
                                                    * @param authNames The authentications to apply
                                                    */
    protected void updateParamsForAuth(String[]
                                               authNames, List<Pair> queryParams, Map<String, String> headerParams) {
                                                        for (String authName : authNames) {
                                                        Authentication auth = authentications.get(authName);
                                                        if (auth == null) throw new RuntimeException("Authentication undefined: " + authName);
                                                        auth.applyToParams(queryParams, headerParams);
                                                        }
                                                        }
                                                        }